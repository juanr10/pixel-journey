<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Life</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      background:#222; color:#fff; font-family: system-ui, sans-serif;
      display:flex; flex-direction:column; align-items:center; margin:0; padding:20px;
    }
    h1 { margin:0 0 10px; }
    form {
      margin-top:10px; display:flex; flex-wrap:wrap; gap:8px; justify-content:center;
      background:#2a2a2a; padding:10px; border-radius:10px;
    }
    input, select, button, textarea { padding:8px; border-radius:8px; border:none; }
    button { background:#00c775; color:#111; font-weight:700; cursor:pointer; }
    button.secondary { background:#e9e9e9; color:#222; }
    button.danger { background:#ff5c5c; color:#111; }
    button:hover { filter:brightness(1.05); }
    canvas { background:#4caf50; margin-top:16px; border-radius:8px; cursor:pointer; }
    #modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.5); padding:20px; }
    #modalInner { width:min(92vw,460px); background:#fff; color:#111; border-radius:12px; padding:16px; box-shadow:0 10px 40px rgba(0,0,0,.4); }
    #modal h2 { margin:0 0 6px; }
    #modal p { margin:6px 0 10px; }
    #modalActions { display:flex; justify-content:space-between; gap:8px; margin-top:10px; }
    #editRow { display:grid; grid-template-columns: 1fr 160px; gap:8px; margin-top:8px; }
    #idRow { font-size:.85rem; color:#666; margin-top:4px; }
    .muted { opacity:.8; }
  </style>
</head>
<body>
  <h1>Pixel Life</h1>

  <!-- Alta de recuerdos -->
  <form id="memoryForm">
    <input type="text" id="memoryText" placeholder="Texto del recuerdo" required />
    <select id="memoryType">
      <option value="travel">Viaje ‚úàÔ∏è</option>
      <option value="mountain">Senderismo üèîÔ∏è</option>
      <option value="game">Videojuego üéÆ</option>
      <option value="love">Rom√°ntico ‚ù§Ô∏è</option>
      <option value="camera">Gen√©rico üì∏</option>
    </select>
    <button type="submit">A√±adir recuerdo</button>
  </form>

  <canvas id="map" width="500" height="600" aria-label="Mapa de recuerdos"></canvas>

  <!-- Modal detalle/edici√≥n -->
  <div id="modal" role="dialog" aria-modal="true">
    <div id="modalInner">
      <h2 id="memoryTitle"></h2>
      <div id="idRow" class="muted"></div>

      <div id="editRow">
        <textarea id="editText" rows="3" placeholder="Editar texto..."></textarea>
        <select id="editType">
          <option value="travel">Viaje ‚úàÔ∏è</option>
          <option value="mountain">Senderismo üèîÔ∏è</option>
          <option value="game">Videojuego üéÆ</option>
          <option value="love">Rom√°ntico ‚ù§Ô∏è</option>
          <option value="camera">Gen√©rico üì∏</option>
        </select>
      </div>

      <div id="modalActions">
        <div>
          <button class="danger" id="deleteBtn">Eliminar</button>
        </div>
        <div>
          <button class="secondary" onclick="closeModal()">Cerrar</button>
          <button id="saveBtn">Guardar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= Config =========
    const CONFIG = {
      SHOW_GRID: false,             // l√≠neas del grid visibles siempre
      SHOW_GRID_DURING_ANIM: false, // grid durante la animaci√≥n
      SHOW_POIS: true,              // mostrar POIs (marcadores peque√±os)
      CRISP_ALIGN: true,            // alinear sprites a p√≠xel
      ANIM_DURATION_MS: 900
    };

    // ========= Utils =========
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const easeInOut = t => (t<.5) ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

    // PRNG determinista
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}
    function seeded(seed, salt){ const s=(seed ^ (salt*0x9E3779B9))>>>0; return mulberry32(s)(); }
    function randIntSeeded(min, max, seed, salt){ const r=seeded(seed, salt); return Math.floor(r*(max-min+1))+min; }
    function randSignSeeded(seed, salt){ return seeded(seed, salt)<0.5 ? -1 : 1; }

    // ========= Mapa / Estado =========
    const tileSize = 50;
    let gridW = 10;                 // columnas
    let gridH = 12;                 // filas (crece hacia abajo)
    const houseCol = 0;             // casa izq
    const houseRow = 0;             // arriba
    const minX = 1, maxX = gridW - 2; // margen lateral camino

    // Semilla persistente
    let seed = Number(localStorage.getItem("pixelLifeSeed"));
    if (!seed) { seed = (Date.now() ^ Math.floor(Math.random() * 1e9)) >>> 0; localStorage.setItem("pixelLifeSeed", String(seed)); }

    // Datos
    let memories = JSON.parse(localStorage.getItem("memories") || "[]");
    // Cada item: { type, text, createdAt }

    // ========= Canvas =========
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");

    function setupCrispCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const logicalW = gridW * tileSize;
      const logicalH = gridH * tileSize;
      canvas.style.width = logicalW + "px";
      canvas.style.height = logicalH + "px";
      canvas.width  = Math.round(logicalW * dpr);
      canvas.height = Math.round(logicalH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }

    // ========= Sprites =========
    const spriteUrls = {
      house: "./assets/sprites/memories/house.png",
      juan: "./assets/sprites/memories/juan.png",
      paula: "./assets/sprites/memories/paula.png",
      mountain: "./assets/sprites/memories/mountain.png",
      travel: "./assets/sprites/memories/travel.png",
      game: "./assets/sprites/memories/game.png",
      love: "./assets/sprites/memories/love.png",
      camera: "./assets/sprites/memories/camera.png"
    };
    const sprites = {};
    let loaded = 0, needed = Object.keys(spriteUrls).length;

    function loadImage(target, key, url){
      const img = new Image();
      img.onload = () => { loaded++; if (loaded === needed) { ensureCapacity(); drawMap(); } };
      img.onerror = () => { console.warn("No se carg√≥:", url); loaded++; if (loaded === needed) { ensureCapacity(); drawMap(); } };
      img.src = url; target[key] = img;
    }
    for (const [k,u] of Object.entries(spriteUrls)) loadImage(sprites, k, u);

    // ========= Mundo simple (colores) =========
    function tileType(x, y) {
      const r = seeded(seed, (x+1)*73856093 ^ (y+1)*19349663);
      if (r < 0.08) return 2;      // agua
      if (r < 0.28) return 1;      // bosque
      if (r < 0.40) return 3;      // colina
      return 0;                    // llanura
    }
    function drawTiles() {
      for (let x=0; x<gridW; x++){
        for (let y=0; y<gridH; y++){
          const t = tileType(x,y);
          if (t === 2) ctx.fillStyle = "#87c7e6";
          else if (t === 1) ctx.fillStyle = "#3a7a39";
          else if (t === 3) ctx.fillStyle = "#6b8e23";
          else ctx.fillStyle = "#4caf50";
          ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
        }
      }
    }

    // ========= Camino (determinista) =========
    function computeWaypointsAndPolyline() {
      const waypoints = [];   // {x,y,idx}
      const polyline = [];    // puntos (px) del sendero

      let curX = houseCol;
      let curY = houseRow;
      if (gridW > 1) curX = 1; // primer paso a la derecha

      polyline.push(cellCenter(houseCol, houseRow));
      polyline.push(cellCenter(curX, curY));

      for (let i = 0; i < memories.length; i++) {
        const rows = randIntSeeded(2, 3, seed, 1000 + i);
        const lateral = randIntSeeded(1, 8, seed, 2000 + i) * randSignSeeded(seed, 3000 + i);
        let targetX = clamp(curX + lateral, minX, maxX);

        const wiggles = Array.from({length: rows}, (_, step) => {
          const r = seeded(seed, (i+1) * 4000 + step);
          return r < 0.18 ? -1 : (r > 0.82 ? 1 : 0);
        });

        let nextX = curX;
        for (let step = 1; step <= rows; step++) {
          const y = curY + step;
          const toward = Math.sign(targetX - nextX);
          if (toward !== 0) nextX = clamp(nextX + toward, minX, maxX);
          nextX = clamp(nextX + wiggles[step-1], minX, maxX);
          polyline.push(cellCenter(nextX, y));
        }
        curX = nextX;
        curY += rows;
        waypoints.push({ x: curX, y: curY, idx: i });
      }

      return { waypoints, polyline };
    }

    function ensureCapacity() {
      const { waypoints } = computeWaypointsAndPolyline();
      const lastY = waypoints.length ? waypoints[waypoints.length-1].y : 0;
      gridH = Math.max(12, lastY + 4); // margen bajo
      setupCrispCanvas();               // DPR + smoothing off
    }

    // ========= Dibujo =========
    function drawGridLines(show = true) {
      if (!show) return;
      ctx.strokeStyle = "rgba(0,0,0,.18)";
      for (let i = 0; i < gridW; i++) {
        const x = i*tileSize + 0.5;
        ctx.beginPath(); ctx.moveTo(x, 0.5); ctx.lineTo(x, gridH*tileSize + 0.5); ctx.stroke();
      }
      for (let j = 0; j < gridH; j++) {
        const y = j*tileSize + 0.5;
        ctx.beginPath(); ctx.moveTo(0.5, y); ctx.lineTo(gridW*tileSize + 0.5, y); ctx.stroke();
      }
    }
    function cellCenter(x, y) { return { x: x*tileSize + tileSize/2, y: y*tileSize + tileSize/2 }; }

    function drawSprite(img, x, y, w, h) {
      const dx = CONFIG.CRISP_ALIGN ? Math.round(x) : x;
      const dy = CONFIG.CRISP_ALIGN ? Math.round(y) : y;
      ctx.drawImage(img, dx, dy, w, h);
    }

    function drawPath(polyline, uptoIndex = polyline.length - 1) {
      if (polyline.length < 2) return;
      uptoIndex = Math.max(1, Math.min(uptoIndex, polyline.length - 1));

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      // Base
      ctx.beginPath();
      ctx.moveTo(Math.round(polyline[0].x), Math.round(polyline[0].y));
      for (let i = 1; i <= uptoIndex; i++) ctx.lineTo(Math.round(polyline[i].x), Math.round(polyline[i].y));
      ctx.strokeStyle = "#c2b280";
      ctx.lineWidth = 22;
      ctx.stroke();

      // Luz superior
      ctx.beginPath();
      ctx.moveTo(Math.round(polyline[0].x), Math.round(polyline[0].y));
      for (let i = 1; i <= uptoIndex; i++) ctx.lineTo(Math.round(polyline[i].x), Math.round(polyline[i].y));
      ctx.strokeStyle = "#e8d7a5";
      ctx.lineWidth = 10;
      ctx.stroke();

      // Puntos intermedios
      if (CONFIG.SHOW_POIS) {
        ctx.fillStyle = "#f0e3b5";
        for (let i = 1; i <= uptoIndex; i++) {
          if (i % 3 === 0) {
            ctx.beginPath();
            ctx.arc(Math.round(polyline[i].x), Math.round(polyline[i].y), 3, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }
    }

    function drawHouseAndAvatars() {
      drawSprite(sprites.house, houseCol*tileSize, houseRow*tileSize, tileSize, tileSize);
      if (gridW >= 3) {
        drawSprite(sprites.juan,  1*tileSize, 0*tileSize, tileSize, tileSize);
        drawSprite(sprites.paula, 2*tileSize, 0*tileSize, tileSize, tileSize);
      }
    }

    function drawPOIAt(x, y, type) {
      if (!CONFIG.SHOW_POIS) return;
      // Peque√±o rombo tipo marcador; posici√≥n relativa a la celda del icono
      ctx.save();
      ctx.translate(x*tileSize + tileSize*0.78, y*tileSize + tileSize*0.22);
      ctx.rotate(Math.PI/4);
      // tono seg√∫n tipo para distinguir
      const c = ({
        travel:  "#ffd27a",
        mountain:"#d2ff7a",
        game:    "#7ad2ff",
        love:    "#ff99c8",
        camera:  "#f0e3b5"
      })[type] || "#f0e3b5";
      ctx.fillStyle = c;
      ctx.fillRect(-4,-4,8,8);
      ctx.restore();
    }

    function drawIcons(waypoints, uptoIdx = waypoints.length - 1) {
      for (let k = 0; k <= uptoIdx && k < waypoints.length; k++) {
        const w = waypoints[k];
        const m = memories[w.idx];
        const icon = sprites[m.type] ?? sprites.camera;
        drawSprite(icon, w.x*tileSize + 8, w.y*tileSize + 8, 35, 35);
        drawPOIAt(w.x, w.y, m.type); // POI peque√±o cerca del icono
      }
    }

    function drawMap() {
      const { waypoints, polyline } = computeWaypointsAndPolyline();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTiles();
      drawGridLines(CONFIG.SHOW_GRID);
      drawPath(polyline);
      drawHouseAndAvatars();
      drawIcons(waypoints);
    }

    // ========= Animaci√≥n del √∫ltimo tramo =========
    function animateLastSegment() {
      const { waypoints, polyline } = computeWaypointsAndPolyline();
      if (waypoints.length === 0) { drawMap(); return; }

      let prevEnd = 1;
      if (memories.length > 1) {
        const prevMems = memories.slice(0, memories.length - 1);
        const keep = memories;
        memories = prevMems;
        const old = computeWaypointsAndPolyline();
        prevEnd = old.polyline.length - 1;
        memories = keep;
      }
      const totalEnd = polyline.length - 1;
      const DURATION = CONFIG.ANIM_DURATION_MS;
      let start = null;

      function render(progressIdx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTiles();
        drawGridLines(CONFIG.SHOW_GRID_DURING_ANIM);
        drawPath(polyline, progressIdx);
        drawHouseAndAvatars();

        const uptoWp = countWaypointsVisible(polyline, progressIdx);
        drawIcons(waypoints, uptoWp);

        // Personajito (suave)
        const a = polyline[progressIdx];
        const b = polyline[Math.min(progressIdx+1, totalEnd)];
        const px = a.x, py = a.y;
        if (sprites.juan && sprites.juan.width) {
          ctx.drawImage(sprites.juan, px-16, py-16, 32, 32);
        } else {
          ctx.fillStyle = "#fff";
          ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2); ctx.fill();
        }
      }

      function step(ts) {
        if (!start) start = ts;
        const t = Math.min(1, (ts - start) / DURATION);
        const eased = easeInOut(t);
        const idxFloat = prevEnd + eased * (totalEnd - prevEnd);
        const idx = Math.max(prevEnd, Math.min(totalEnd, Math.floor(idxFloat)));

        render(idx);
        if (t < 1) requestAnimationFrame(step);
        else drawMap();
      }
      requestAnimationFrame(step);
    }

    function countWaypointsVisible(polyline, uptoIdx) {
      const { waypoints } = computeWaypointsAndPolyline();
      let visible = -1;
      for (let k = 0; k < waypoints.length; k++) {
        const w = waypoints[k];
        const c = cellCenter(w.x, w.y);
        for (let i = 0; i <= uptoIdx; i++) {
          const p = polyline[i];
          if (Math.hypot(p.x - c.x, p.y - c.y) < 1e-3) { visible = k; break; }
        }
      }
      return visible;
    }

    // ========= Formulario (alta) =========
    document.getElementById("memoryForm").addEventListener("submit", (e) => {
      e.preventDefault();
      const text = document.getElementById("memoryText").value.trim();
      const type = document.getElementById("memoryType").value;
      if (!text) return;

      memories.push({ type, text, createdAt: new Date().toISOString() });
      localStorage.setItem("memories", JSON.stringify(memories));

      ensureCapacity();
      animateLastSegment();
      e.target.reset();
    });

    // ========= Modal edici√≥n/borrado =========
    const modal = document.getElementById("modal");
    const titleEl = document.getElementById("memoryTitle");
    const idRow = document.getElementById("idRow");
    const editText = document.getElementById("editText");
    const editType = document.getElementById("editType");
    const saveBtn = document.getElementById("saveBtn");
    const deleteBtn = document.getElementById("deleteBtn");
    let currentIdx = null;

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const gx = Math.floor((e.clientX - rect.left) / tileSize);
      const gy = Math.floor((e.clientY - rect.top) / tileSize);

      const { waypoints } = computeWaypointsAndPolyline();
      const hit = waypoints.find(w => w.x === gx && w.y === gy);
      if (!hit) return;

      currentIdx = hit.idx;
      const m = memories[currentIdx];
      const title = ({
        mountain: "Senderismo üèîÔ∏è",
        travel: "Viaje ‚úàÔ∏è",
        game: "Videojuego üéÆ",
        love: "Rom√°ntico ‚ù§Ô∏è",
        camera: "Recuerdo üì∏"
      })[m.type] ?? "Recuerdo";

      titleEl.textContent = title;
      idRow.textContent = `√çndice: ${currentIdx} ¬∑ Fecha: ${new Date(m.createdAt).toLocaleString()}`;
      editText.value = m.text || "";
      editType.value = m.type;

      modal.style.display = "flex";
      setTimeout(()=>editText.focus(), 0);
    });

    saveBtn.addEventListener("click", () => {
      if (currentIdx == null) return;
      const newText = editText.value.trim();
      const newType = editType.value;
      memories[currentIdx].text = newText;
      memories[currentIdx].type = newType;
      localStorage.setItem("memories", JSON.stringify(memories));
      closeModal();
      drawMap(); // redibuja (el icono puede cambiar)
    });

    deleteBtn.addEventListener("click", () => {
      if (currentIdx == null) return;
      const ok = confirm("¬øSeguro que quieres eliminar este recuerdo? Esta acci√≥n no se puede deshacer.");
      if (!ok) return;
      memories.splice(currentIdx, 1);
      localStorage.setItem("memories", JSON.stringify(memories));
      currentIdx = null;
      closeModal();
      ensureCapacity();
      drawMap(); // como cambia el orden/recorrido, recalculamos todo
    });

    function closeModal(){ modal.style.display = "none"; }

    // ========= Inicial =========
    // (sprites onload -> ensureCapacity() -> drawMap())
  </script>
</body>
</html>
