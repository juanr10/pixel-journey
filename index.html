<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Life</title>
  <!-- Fuente retro estilo Mario -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root { color-scheme: light dark; }
    body {
      background:#222; color:#fff; font-family: system-ui, sans-serif;
      display:flex; flex-direction:column; align-items:center; margin:0; padding:20px;
    }

    h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: 28px;
      margin:0 0 20px;
      color: #ffcc00;
      text-shadow: 3px 3px 0 #000, 6px 6px 0 #d62828;
      letter-spacing: 1px;
    }

    button {
      padding:10px 16px; border-radius:8px; border:none; font-weight:700; cursor:pointer;
    }
    button.primary { background:#00c775; color:#111; }
    button.secondary { background:#e9e9e9; color:#222; }
    button.danger { background:#ff5c5c; color:#111; }
    button:hover { filter:brightness(1.05); }

    canvas { background:#4caf50; margin-top:16px; border-radius:8px; cursor:pointer; }

    /* No scroll cuando un modal est√° abierto */
    body.no-scroll { overflow: hidden; }

    /* ==== Modales con transiciones ==== */
    .modal {
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.5);
      padding:20px;
      opacity:0; visibility:hidden; pointer-events:none;
      transition: opacity .18s ease, visibility .18s ease;
      z-index: 15;
    }
    .modal.show { opacity:1; visibility:visible; pointer-events:auto; }
    .modalInner {
      width:min(92vw,480px);
      background:#fff; color:#111;
      border-radius:12px; padding:20px;
      box-shadow:0 10px 40px rgba(0,0,0,.4);
      transform: scale(.98);
      opacity:.95;
      transition: transform .18s ease, opacity .18s ease;
    }
    .modal.show .modalInner { transform: scale(1); opacity:1; }

    .modal h2 { margin:0 0 16px; font-family: 'Press Start 2P', cursive; font-size:14px; color:#333; }
    .formRow { display:flex; flex-direction:column; margin-bottom:14px; }
    .formRow label { font-size:.85rem; margin-bottom:4px; color:#444; }
    .formRow input, .formRow textarea, .formRow select {
      padding:8px; border-radius:6px; border:1px solid #ccc; font-family:inherit;
    }
    .modalActions { display:flex; justify-content:space-between; gap:8px; margin-top:16px; }
    .muted { opacity:.8; font-size:.85rem; color:#666; margin-bottom:14px; }
  </style>
</head>

<body>
  <h1>Pixel Life</h1>

  <!-- Bot√≥n superior para abrir modal de alta -->
  <button id="openAddModal" class="primary">+ A√±adir recuerdo</button>

  <canvas id="map" width="480" height="576" aria-label="Mapa de recuerdos"></canvas>

  <!-- Modal A√±adir -->
  <div id="addModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalInner">
      <h2>Nuevo recuerdo</h2>

      <!-- addMeta ANTES de la categor√≠a (checkpoint) -->
      <div id="addMeta" class="muted"></div>

      <div class="formRow">
        <label for="addType">Categor√≠a</label>
        <select id="addType">
          <option value="travel">Viaje ‚úàÔ∏è</option>
          <option value="mountain">Senderismo üèîÔ∏è</option>
          <option value="game">Videojuego üéÆ</option>
          <option value="love">Rom√°ntico ‚ù§Ô∏è</option>
          <option value="camera">Gen√©rico üì∏</option>
        </select>
      </div>

      <div class="formRow">
        <label for="addTitle">T√≠tulo</label>
        <input type="text" id="addTitle" placeholder="Ej. Viaje a Par√≠s" required>
      </div>

      <div class="formRow">
        <label for="addText">Descripci√≥n</label>
        <textarea id="addText" rows="3" placeholder="Escribe un detalle bonito..." required></textarea>
      </div>

      <div class="modalActions">
        <div></div>
        <div>
          <button class="secondary" id="cancelAdd">Cancelar</button>
          <button class="primary" id="saveAdd">Guardar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal detalle/edici√≥n -->
  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="modalInner">
      <h2 id="memoryTitle"></h2>

      <div id="idRow" class="muted"></div>

      <div class="formRow">
        <label for="editType">Categor√≠a</label>
        <select id="editType">
          <option value="travel">Viaje ‚úàÔ∏è</option>
          <option value="mountain">Senderismo üèîÔ∏è</option>
          <option value="game">Videojuego üéÆ</option>
          <option value="love">Rom√°ntico ‚ù§Ô∏è</option>
          <option value="camera">Gen√©rico üì∏</option>
        </select>
      </div>

      <div class="formRow">
        <label for="editTitle">T√≠tulo</label>
        <input type="text" id="editTitle" />
      </div>

      <div class="formRow">
        <label for="editText">Descripci√≥n</label>
        <textarea id="editText" rows="3"></textarea>
      </div>

      <div class="modalActions">
        <div>
          <button class="danger" id="deleteBtn">Eliminar</button>
        </div>
        <div>
          <button class="secondary" onclick="closeModal()">Cerrar</button>
          <button class="primary" id="saveBtn">Guardar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= Config =========
    const CONFIG = {
      SHOW_GRID: false,
      SHOW_GRID_DURING_ANIM: false,
      SHOW_POIS: true,            // POIs del camino + rombitos junto a iconos
      CRISP_ALIGN: true,
      ANIM_DURATION_MS: 900
    };

    // ========= Pixel-art / Tiles =========
    const TILE_SRC_PX = 16;   // tama√±o real del tile en el PNG
    const TILE_SCALE  = 3;    // escala entera para mantener nitidez (3 -> 48px)
    const tileSize    = TILE_SRC_PX * TILE_SCALE; // 48

    // ========= Utils =========
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const easeInOut = t => (t<.5) ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

    // PRNG determinista
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}
    function seeded(seed, salt){ const s=(seed ^ (salt*0x9E3779B9))>>>0; return mulberry32(s)(); }
    function randIntSeeded(min, max, seed, salt){ const r=seeded(seed, salt); return Math.floor(r*(max-min+1))+min; }
    function randSignSeeded(seed, salt){ return seeded(seed, salt)<0.5 ? -1 : 1; }

    // ========= Mapa / Estado =========
    let gridW = 10;
    let gridH = 12;
    const houseCol = 0, houseRow = 0;
    const minX = 1, maxX = gridW - 2;

    // Semilla y datos
    let seed = Number(localStorage.getItem("pixelLifeSeed"));
    if (!seed) { seed = (Date.now() ^ Math.floor(Math.random() * 1e9)) >>> 0; localStorage.setItem("pixelLifeSeed", String(seed)); }
    // Recuerdos: { title, text, type, createdAt }
    let memories = JSON.parse(localStorage.getItem("memories") || "[]");

    // ========= Canvas =========
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    function setupCrispCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const logicalW = gridW * tileSize;  // ajusta al tileSize nuevo
      const logicalH = gridH * tileSize;
      canvas.style.width = logicalW + "px";
      canvas.style.height = logicalH + "px";
      canvas.width  = Math.round(logicalW * dpr);
      canvas.height = Math.round(logicalH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }

    // ========= Sprites (iconos y casa) =========
    const spriteUrls = {
      house: "./assets/sprites/memories/house.png",
      juan: "./assets/sprites/memories/juan.png",
      paula: "./assets/sprites/memories/paula.png",
      mountain: "./assets/sprites/memories/mountain.png",
      travel: "./assets/sprites/memories/travel.png",
      game: "./assets/sprites/memories/game.png",
      love: "./assets/sprites/memories/love.png",
      camera: "./assets/sprites/memories/camera.png"
    };
    const sprites = {};
    let loaded = 0, needed = Object.keys(spriteUrls).length;

    function loadImage(target, key, url){
      const img = new Image();
      img.onload = () => { loaded++; if (loaded === needed && tilesetReady()) { ensureCapacity(); drawMap(); } };
      img.onerror = () => { loaded++; if (loaded === needed && tilesetReady()) { ensureCapacity(); drawMap(); } };
      img.src = url; target[key] = img;
    }
    for (const [k,u] of Object.entries(spriteUrls)) loadImage(sprites, k, u);

    // ========= Tileset =========
    const tilesetUrl = "./assets/tiles/tileset_pixel_life.png"; // coloca aqu√≠ el PNG
    let tilesetImg = new Image();
    let tilesetLoaded = false;
    tilesetImg.onload = () => { tilesetLoaded = true; if (loaded === needed) { ensureCapacity(); drawMap(); } };
    tilesetImg.onerror = () => { console.warn("No se carg√≥ tileset:", tilesetUrl); tilesetLoaded = false; if (loaded === needed) { ensureCapacity(); drawMap(); } };
    tilesetImg.src = tilesetUrl;

    function tilesetReady(){ return tilesetLoaded; }

    function blitTile(tileIndex, dx, dy) {
      if (!tilesetReady()) return; // si no carg√≥, no dibuja (fallback es el bg del canvas)
      const sx = tileIndex * TILE_SRC_PX;
      const sy = 0;
      const sw = TILE_SRC_PX, sh = TILE_SRC_PX;
      const dw = tileSize, dh = tileSize;
      const px = CONFIG.CRISP_ALIGN ? Math.round(dx) : dx;
      const py = CONFIG.CRISP_ALIGN ? Math.round(dy) : dy;
      ctx.drawImage(tilesetImg, sx, sy, sw, sh, px, py, dw, dh);
    }

    // Mundo ‚Üí tipo de tile por celda
    function tileType(x, y) {
      const r = seeded(seed, (x+1)*73856093 ^ (y+1)*19349663);
      if (r < 0.08) return 2; // agua
      if (r < 0.28) return 1; // bosque
      if (r < 0.40) return 3; // colina
      return 0;               // llanura
    }

    function drawTiles() {
      for (let x=0; x<gridW; x++){
        for (let y=0; y<gridH; y++){
          const t = tileType(x,y); // 0=llanura,1=bosque,2=agua,3=colina
          const index = (t===0)?0 : (t===1)?1 : (t===2)?2 : (t===3)?3 : 0;
          blitTile(index, x*tileSize, y*tileSize);
        }
      }
    }

    // Helpers
    function cellCenter(x, y) { return { x: x*tileSize + tileSize/2, y: y*tileSize + tileSize/2 }; }
    function drawSprite(img, x, y, w, h) {
      const dx = CONFIG.CRISP_ALIGN ? Math.round(x) : x;
      const dy = CONFIG.CRISP_ALIGN ? Math.round(y) : y;
      ctx.drawImage(img, dx, dy, w, h);
    }

    // Camino determinista
    function computeWaypointsAndPolyline() {
      const waypoints=[], polyline=[];
      let curX=houseCol, curY=houseRow;
      if (gridW>1) curX=1; // primer paso a la derecha
      polyline.push(cellCenter(houseCol, houseRow));
      polyline.push(cellCenter(curX, curY));

      for (let i=0;i<memories.length;i++){
        const rows=randIntSeeded(2,3,seed,1000+i);
        const lateral=randIntSeeded(1,8,seed,2000+i)*randSignSeeded(seed,3000+i);
        let targetX=clamp(curX+lateral,minX,maxX);

        const wiggles=Array.from({length:rows},(_,s)=>{const r=seeded(seed,(i+1)*4000+s);return r<.18?-1:(r>.82?1:0);});
        let nextX=curX;
        for(let step=1;step<=rows;step++){
          const y=curY+step;
          const toward=Math.sign(targetX-nextX);
          if(toward!==0) nextX=clamp(nextX+toward,minX,maxX);
          nextX=clamp(nextX+wiggles[step-1],minX,maxX);
          polyline.push(cellCenter(nextX,y));
        }
        curX=nextX;curY+=rows;
        waypoints.push({x:curX,y:curY,idx:i});
      }
      return {waypoints,polyline};
    }

    function ensureCapacity(){
      const {waypoints}=computeWaypointsAndPolyline();
      const lastY=waypoints.length?waypoints[waypoints.length-1].y:0;
      gridH=Math.max(12,lastY+4);
      setupCrispCanvas();
    }

    // POIs
    function drawPOIAtCell(cellX, cellY, type) {
      if (!CONFIG.SHOW_POIS) return;
      ctx.save();
      ctx.translate(cellX*tileSize + tileSize*0.78, cellY*tileSize + tileSize*0.22);
      ctx.rotate(Math.PI/4);
      const c = ({
        travel:  "#ffd27a",
        mountain:"#d2ff7a",
        game:    "#7ad2ff",
        love:    "#ff99c8",
        camera:  "#f0e3b5"
      })[type] || "#f0e3b5";
      ctx.fillStyle = c;
      ctx.fillRect(-4,-4,8,8);
      ctx.restore();
    }

    function drawPath(polyline, uptoIndex = polyline.length - 1) {
      if (polyline.length < 2) return;
      uptoIndex = Math.max(1, Math.min(uptoIndex, polyline.length - 1));

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      // Base
      ctx.beginPath();
      ctx.moveTo(Math.round(polyline[0].x), Math.round(polyline[0].y));
      for (let i = 1; i <= uptoIndex; i++) ctx.lineTo(Math.round(polyline[i].x), Math.round(polyline[i].y));
      ctx.strokeStyle = "#c2b280";
      ctx.lineWidth = 22;
      ctx.stroke();

      // Luz superior
      ctx.beginPath();
      ctx.moveTo(Math.round(polyline[0].x), Math.round(polyline[0].y));
      for (let i = 1; i <= uptoIndex; i++) ctx.lineTo(Math.round(polyline[i].x), Math.round(polyline[i].y));
      ctx.strokeStyle = "#e8d7a5";
      ctx.lineWidth = 10;
      ctx.stroke();

      // POIs del camino (cada 3 puntos de la polil√≠nea)
      if (CONFIG.SHOW_POIS) {
        ctx.fillStyle = "#f0e3b5";
        for (let i = 1; i <= uptoIndex; i++) {
          if (i % 3 === 0) {
            ctx.beginPath();
            ctx.arc(Math.round(polyline[i].x), Math.round(polyline[i].y), 3, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }
    }

    function drawHouseAndAvatars(){
      drawSprite(sprites.house,0,0,tileSize,tileSize);
      if(gridW>=3){
        drawSprite(sprites.juan,  1*tileSize,0,tileSize,tileSize);
        drawSprite(sprites.paula, 2*tileSize,0,tileSize,tileSize);
      }
    }

    function drawIcons(waypoints, uptoIdx = waypoints.length - 1){
      for (let k = 0; k <= uptoIdx && k < waypoints.length; k++) {
        const w = waypoints[k];
        const m = memories[w.idx];
        const icon = sprites[m.type] ?? sprites.camera;
        // Icono del recuerdo
        drawSprite(icon, w.x*tileSize + 8, w.y*tileSize + 8, Math.round(tileSize*0.73), Math.round(tileSize*0.73));
        // POI peque√±o junto al icono
        drawPOIAtCell(w.x, w.y, m.type);
      }
    }

    function drawMap(){
      const {waypoints,polyline}=computeWaypointsAndPolyline();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawTiles();                 // ahora pinta tiles del PNG
      drawPath(polyline);
      drawHouseAndAvatars();
      drawIcons(waypoints);
    }

    // Contar waypoints alcanzados hasta un √≠ndice de polil√≠nea
    function countWaypointsVisible(polyline, uptoIdx) {
      const { waypoints } = computeWaypointsAndPolyline();
      let visible = -1;
      for (let k = 0; k < waypoints.length; k++) {
        const w = waypoints[k];
        const c = cellCenter(w.x, w.y);
        for (let i = 0; i <= uptoIdx; i++) {
          const p = polyline[i];
          if (Math.hypot(p.x - c.x, p.y - c.y) < 1e-3) { visible = k; break; }
        }
      }
      return visible;
    }

    // ========= Animaci√≥n al a√±adir =========
    function animateLastSegment() {
      const { waypoints, polyline } = computeWaypointsAndPolyline();
      if (waypoints.length === 0) { drawMap(); return; }

      // √çndice donde acababa antes
      let prevEnd = 1;
      if (memories.length > 1) {
        const prevMems = memories.slice(0, memories.length - 1);
        const keep = memories;
        memories = prevMems;
        const old = computeWaypointsAndPolyline();
        prevEnd = old.polyline.length - 1;
        memories = keep;
      }
      const totalEnd = polyline.length - 1;
      const DURATION = CONFIG.ANIM_DURATION_MS;
      let start = null;

      function render(progressIdx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTiles();
        drawPath(polyline, progressIdx);
        drawHouseAndAvatars();

        // Iconos ya ‚Äúalcanzados‚Äù
        const uptoWp = countWaypointsVisible(polyline, progressIdx);
        drawIcons(waypoints, uptoWp);

        // Personajito suave
        const a = polyline[progressIdx];
        const px = a.x, py = a.y;
        if (sprites.juan && sprites.juan.width) {
          ctx.drawImage(sprites.juan, px-16, py-16, 32, 32);
        } else {
          ctx.fillStyle = "#fff";
          ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2); ctx.fill();
        }
      }

      function step(ts) {
        if (!start) start = ts;
        const t = Math.min(1, (ts - start) / DURATION);
        const eased = easeInOut(t);
        const idx = Math.max(prevEnd, Math.min(totalEnd, Math.floor(prevEnd + eased * (totalEnd - prevEnd))));
        render(idx);
        if (t < 1) requestAnimationFrame(step);
        else drawMap();
      }
      requestAnimationFrame(step);
    }

    // ========= Helpers de modal (UI) =========
    function showModal(el){
      el.classList.add('show');
      document.body.classList.add('no-scroll');
    }
    function hideModal(el){
      el.classList.remove('show');
      document.body.classList.remove('no-scroll');
    }

    // ===== Alta (modal A√±adir) =====
    const openAddModalBtn=document.getElementById("openAddModal");
    const addModal=document.getElementById("addModal");
    const cancelAdd=document.getElementById("cancelAdd");
    const saveAdd=document.getElementById("saveAdd");
    const addTitle=document.getElementById("addTitle");
    const addText=document.getElementById("addText");
    const addType=document.getElementById("addType");
    const addMeta=document.getElementById("addMeta");

    function openAddModal(){
      addTitle.value=""; addText.value="";
      addType.value="camera";
      addMeta.textContent=`√çndice: ${memories.length} ¬∑ Fecha: ${new Date().toLocaleString()}`;
      showModal(addModal);
      setTimeout(()=>addTitle.focus(),0);
    }

    openAddModalBtn.addEventListener("click", openAddModal);
    cancelAdd.addEventListener("click",()=> hideModal(addModal));
    saveAdd.addEventListener("click",()=>{
      const title=addTitle.value.trim(), text=addText.value.trim(), type=addType.value;
      if(!title||!text) return alert("Completa todos los campos.");
      memories.push({title,text,type,createdAt:new Date().toISOString()});
      localStorage.setItem("memories",JSON.stringify(memories));
      ensureCapacity();
      animateLastSegment();
      hideModal(addModal);
    });

    // ===== Edici√≥n =====
    const modal=document.getElementById("modal");
    const titleEl=document.getElementById("memoryTitle");
    const idRow=document.getElementById("idRow");
    const editTitle=document.getElementById("editTitle");
    const editText=document.getElementById("editText");
    const editType=document.getElementById("editType");
    const saveBtn=document.getElementById("saveBtn");
    const deleteBtn=document.getElementById("deleteBtn");
    let currentIdx=null;

    canvas.addEventListener("click",e=>{
      const rect=canvas.getBoundingClientRect();
      const gx=Math.floor((e.clientX-rect.left)/tileSize);
      const gy=Math.floor((e.clientY-rect.top)/tileSize);
      const {waypoints}=computeWaypointsAndPolyline();
      const hit=waypoints.find(w=>w.x===gx&&w.y===gy);
      if(!hit) return;
      currentIdx=hit.idx;const m=memories[currentIdx];
      const fallback=({mountain:"Senderismo üèîÔ∏è",travel:"Viaje ‚úàÔ∏è",game:"Videojuego üéÆ",love:"Rom√°ntico ‚ù§Ô∏è",camera:"Recuerdo üì∏"})[m.type]??"Recuerdo";
      titleEl.textContent=m.title||fallback;
      idRow.textContent=`√çndice: ${currentIdx} ¬∑ Fecha: ${new Date(m.createdAt).toLocaleString()}`;
      editTitle.value=m.title||"";editText.value=m.text||"";editType.value=m.type;
      showModal(modal);
    });

    function closeModal(){ hideModal(modal); }

    saveBtn.addEventListener("click",()=>{
      if(currentIdx==null)return;
      memories[currentIdx].title=editTitle.value.trim()||"Recuerdo";
      memories[currentIdx].text=editText.value.trim();
      memories[currentIdx].type=editType.value;
      localStorage.setItem("memories",JSON.stringify(memories));
      closeModal();drawMap();
    });

    deleteBtn.addEventListener("click",()=>{
      if(currentIdx==null)return;
      if(!confirm("¬øSeguro que quieres eliminar este recuerdo?"))return;
      memories.splice(currentIdx,1);
      localStorage.setItem("memories",JSON.stringify(memories));
      currentIdx=null;closeModal();ensureCapacity();drawMap();
    });

    // Cerrar al hacer click en el fondo (backdrop) y con ESC
    ;[addModal, modal].forEach(m => {
      m.addEventListener('click', (e) => { if (e.target === m) hideModal(m); });
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (addModal.classList.contains('show')) hideModal(addModal);
        if (modal.classList.contains('show')) hideModal(modal);
      }
    });
  </script>
</body>
</html>
