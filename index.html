<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Life</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root { color-scheme: light dark; }
    body {
      background:#222; color:#fff; font-family: system-ui, sans-serif;
      display:flex; flex-direction:column; align-items:center; margin:0; padding:20px;
    }
    header {
      width:100%; max-width:640px; display:flex; align-items:center; justify-content:space-between;
      gap:12px; margin-bottom:16px;
    }
    h1 {
      font-family:'Press Start 2P', cursive;
      font-size:28px; margin:0;
      color:#ffcc00; text-shadow:3px 3px 0 #000, 6px 6px 0 #d62828;
      letter-spacing:1px;
    }
    .controls { display:flex; align-items:center; gap:12px; }
    .switch { display:flex; align-items:center; gap:6px; font-size:12px; opacity:.9; }
    .switch input { transform: scale(1.1); }

    button { padding:10px 16px; border-radius:8px; border:none; font-weight:700; cursor:pointer; }
    button.primary { background:#00c775; color:#111; }
    button.secondary { background:#e9e9e9; color:#222; }
    button.danger { background:#ff5c5c; color:#111; }
    button:hover { filter:brightness(1.05); }
    canvas { background:#4caf50; margin-top:16px; border-radius:8px; cursor:pointer; }

    body.no-scroll { overflow:hidden; }
    .modal {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.5); padding:20px;
      opacity:0; visibility:hidden; pointer-events:none;
      transition:opacity .18s ease, visibility .18s ease; z-index:15;
    }
    .modal.show { opacity:1; visibility:visible; pointer-events:auto; }
    .modalInner {
      width:min(92vw,480px); background:#fff; color:#111; border-radius:12px; padding:20px;
      box-shadow:0 10px 40px rgba(0,0,0,.4); transform:scale(.98); opacity:.95;
      transition:transform .18s ease, opacity .18s ease;
    }
    .modal.show .modalInner { transform:scale(1); opacity:1; }
    .modal h2 { margin:0 0 16px; font-family:'Press Start 2P', cursive; font-size:14px; color:#333; }
    .formRow { display:flex; flex-direction:column; margin-bottom:14px; }
    .formRow label { font-size:.85rem; margin-bottom:4px; color:#444; }
    .formRow input, .formRow textarea, .formRow select { padding:8px; border-radius:6px; border:1px solid #ccc; font-family:inherit; }
    .modalActions { display:flex; justify-content:space-between; gap:8px; margin-top:16px; }
    .muted { opacity:.8; font-size:.85rem; color:#666; margin-bottom:14px; }
  </style>
</head>
<body>
  <header>
    <h1>Pixel Life</h1>
    <div class="controls">
      <label class="switch"><input type="checkbox" id="toggleDayNight" checked> Ciclo d√≠a/noche</label>
      <button id="openAddModal" class="primary">+ A√±adir recuerdo</button>
    </div>
  </header>

  <canvas id="map" width="480" height="576" aria-label="Mapa de recuerdos"></canvas>

  <!-- Modal A√±adir -->
  <div id="addModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalInner">
      <h2>Nuevo recuerdo</h2>
      <div id="addMeta" class="muted"></div>
      <div class="formRow">
        <label for="addType">Categor√≠a</label>
        <select id="addType">
          <option value="travel">Viaje ‚úàÔ∏è</option>
          <option value="mountain">Senderismo üèîÔ∏è</option>
          <option value="game">Videojuego üéÆ</option>
          <option value="love">Rom√°ntico ‚ù§Ô∏è</option>
          <option value="camera">Gen√©rico üì∏</option>
        </select>
      </div>
      <div class="formRow">
        <label for="addTitle">T√≠tulo</label>
        <input type="text" id="addTitle" placeholder="Ej. Viaje a Par√≠s" required>
      </div>
      <div class="formRow">
        <label for="addText">Descripci√≥n</label>
        <textarea id="addText" rows="3" placeholder="Escribe un detalle bonito..." required></textarea>
      </div>
      <div class="modalActions">
        <div></div>
        <div>
          <button class="secondary" id="cancelAdd">Cancelar</button>
          <button class="primary" id="saveAdd">Guardar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal detalle/edici√≥n -->
  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="modalInner">
      <h2 id="memoryTitle"></h2>
      <div id="idRow" class="muted"></div>
      <div class="formRow">
        <label for="editType">Categor√≠a</label>
        <select id="editType">
          <option value="travel">Viaje ‚úàÔ∏è</option>
          <option value="mountain">Senderismo üèîÔ∏è</option>
          <option value="game">Videojuego üéÆ</option>
          <option value="love">Rom√°ntico ‚ù§Ô∏è</option>
          <option value="camera">Gen√©rico üì∏</option>
        </select>
      </div>
      <div class="formRow">
        <label for="editTitle">T√≠tulo</label>
        <input type="text" id="editTitle" />
      </div>
      <div class="formRow">
        <label for="editText">Descripci√≥n</label>
        <textarea id="editText" rows="3"></textarea>
      </div>
      <div class="modalActions">
        <div><button class="danger" id="deleteBtn">Eliminar</button></div>
        <div>
          <button class="secondary" onclick="closeModal()">Cerrar</button>
          <button class="primary" id="saveBtn">Guardar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= Config =========
    const CONFIG = {
      SHOW_GRID: false,
      SHOW_GRID_DURING_ANIM: false,
      SHOW_POIS: true,
      CRISP_ALIGN: true,
      ANIM_DURATION_MS: 900,
      ANIM_IDLE: true,
      DAY_NIGHT: true,
      DAY_NIGHT_SECONDS: 30 // ciclo completo d√≠a->noche->d√≠a
    };

    // ========= Pixel-art / Tiles =========
    const TILE_SRC_PX = 16;
    const TILE_SCALE  = 3;                 // 16*3 = 48px por celda
    const tileSize    = TILE_SRC_PX * TILE_SCALE;

    // ========= Utils =========
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const easeInOut = t => (t<.5) ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}
    function seeded(seed, salt){ const s=(seed ^ (salt*0x9E3779B9))>>>0; return mulberry32(s)(); }
    function randIntSeeded(min, max, seed, salt){ const r=seeded(seed, salt); return Math.floor(r*(max-min+1))+min; }
    function randSignSeeded(seed, salt){ return seeded(seed, salt)<0.5 ? -1 : 1; }

    // ========= Mapa / Estado =========
    let gridW = 10, gridH = 12;
    const houseCol = 0, houseRow = 0;
    const minX = 1, maxX = gridW - 2;

    let seed = Number(localStorage.getItem("pixelLifeSeed"));
    if (!seed) { seed = (Date.now() ^ Math.floor(Math.random() * 1e9)) >>> 0; localStorage.setItem("pixelLifeSeed", String(seed)); }
    let memories = JSON.parse(localStorage.getItem("memories") || "[]");

    // ========= Canvas =========
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    function setupCrispCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const logicalW = gridW * tileSize;
      const logicalH = gridH * tileSize;
      canvas.style.width = logicalW + "px";
      canvas.style.height = logicalH + "px";
      canvas.width  = Math.round(logicalW * dpr);
      canvas.height = Math.round(logicalH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }

    // ========= Sprites =========
    const spriteUrls = {
      house: "./assets/sprites/memories/house.png",
      juan: "./assets/sprites/memories/juan.png",
      paula: "./assets/sprites/memories/paula.png",
      mountain: "./assets/sprites/memories/mountain.png",
      travel: "./assets/sprites/memories/travel.png",
      game: "./assets/sprites/memories/game.png",
      love: "./assets/sprites/memories/love.png",
      camera: "./assets/sprites/memories/camera.png"
    };
    const sprites = {};
    let loaded = 0, needed = Object.keys(spriteUrls).length;
    function loadImage(target, key, url){
      const img = new Image();
      img.onload = () => { loaded++; if (loaded === needed && tilesetReady()) { ensureCapacity(); rebuildStatic(); startIdleLoop(); } };
      img.onerror = () => { loaded++; if (loaded === needed && tilesetReady()) { ensureCapacity(); rebuildStatic(); startIdleLoop(); } };
      img.src = url; target[key] = img;
    }
    for (const [k,u] of Object.entries(spriteUrls)) loadImage(sprites, k, u);

    // ========= Tileset =========
    const tilesetUrl = "./assets/tiles/tileset_pixel_life.png";
    let tilesetImg = new Image();
    let tilesetLoaded = false;
    tilesetImg.onload = () => { tilesetLoaded = true; if (loaded === needed) { ensureCapacity(); rebuildStatic(); startIdleLoop(); } };
    tilesetImg.onerror = () => { console.warn("No se carg√≥ tileset:", tilesetUrl); tilesetLoaded = false; if (loaded === needed) { ensureCapacity(); rebuildStatic(); startIdleLoop(); } };
    tilesetImg.src = tilesetUrl;
    function tilesetReady(){ return tilesetLoaded; }

    function blitTile(tileIndex, dx, dy) {
      if (!tilesetReady()) return;
      const sx = tileIndex * TILE_SRC_PX, sy = 0;
      const sw = TILE_SRC_PX, sh = TILE_SRC_PX;
      const dw = tileSize,   dh = tileSize;
      const px = CONFIG.CRISP_ALIGN ? Math.round(dx) : dx;
      const py = CONFIG.CRISP_ALIGN ? Math.round(dy) : dy;
      ctx.drawImage(tilesetImg, sx, sy, sw, sh, px, py, dw, dh);
    }

    // ========= Mundo base =========
    function tileType(x, y) {
      const r = seeded(seed, (x+1)*73856093 ^ (y+1)*19349663);
      if (r < 0.08) return 2; // agua
      if (r < 0.28) return 1; // bosque
      if (r < 0.40) return 3; // colina
      return 0;               // llano
    }

    function sprinkleGrass(x, y) {
      const baseX = x * tileSize, baseY = y * tileSize;
      const rnd = mulberry32(((x+13)*9973 ^ (y+17)*7919) >>> 0);
      const dots = 3 + Math.floor(rnd()*4);
      for (let i=0;i<dots;i++){
        const px = baseX + 2 + Math.floor(rnd()*(tileSize-4));
        const py = baseY + 2 + Math.floor(rnd()*(tileSize-4));
        ctx.fillStyle = (rnd()<0.5) ? "#49a84a" : "#53b94f";
        ctx.fillRect(Math.round(px), Math.round(py), 1, 1);
      }
    }

    // ========= Camino =========
    function cellCenter(x, y) { return { x: x*tileSize + tileSize/2, y: y*tileSize + tileSize/2 }; }

    function computeWaypointsAndPolyline() {
      const waypoints=[], polyline=[];
      let curX=houseCol, curY=houseRow;
      if (gridW>1) curX=1;
      polyline.push(cellCenter(houseCol, houseRow));
      polyline.push(cellCenter(curX, curY));

      for (let i=0;i<memories.length;i++){
        const rows=randIntSeeded(2,3,seed,1000+i);
        const lateral=randIntSeeded(1,8,seed,2000+i)*randSignSeeded(seed,3000+i);
        let targetX=clamp(curX+lateral,minX,maxX);
        const wiggles=Array.from({length:rows},(_,s)=>{const r=seeded(seed,(i+1)*4000+s);return r<.18?-1:(r>.82?1:0);});
        let nextX=curX;
        for(let step=1;step<=rows;step++){
          const y=curY+step;
          const toward=Math.sign(targetX-nextX);
          if(toward!==0) nextX=clamp(nextX+toward,minX,maxX);
          nextX=clamp(nextX+wiggles[step-1],minX,maxX);
          polyline.push(cellCenter(nextX,y));
        }
        curX=nextX;curY+=rows;
        waypoints.push({x:curX,y:curY,idx:i});
      }
      return {waypoints,polyline};
    }

    function drawPath(polyline, uptoIndex = polyline.length - 1) {
      if (polyline.length < 2) return;
      uptoIndex = Math.max(1, Math.min(uptoIndex, polyline.length - 1));
      ctx.lineCap = "round"; ctx.lineJoin = "round";

      // base
      ctx.beginPath();
      ctx.moveTo(Math.round(polyline[0].x), Math.round(polyline[0].y));
      for (let i = 1; i <= uptoIndex; i++) ctx.lineTo(Math.round(polyline[i].x), Math.round(polyline[i].y));
      ctx.strokeStyle = "#c2b280";
      ctx.lineWidth = 22; ctx.stroke();

      // highlight
      ctx.beginPath();
      ctx.moveTo(Math.round(polyline[0].x), Math.round(polyline[0].y));
      for (let i = 1; i <= uptoIndex; i++) ctx.lineTo(Math.round(polyline[i].x), Math.round(polyline[i].y));
      ctx.strokeStyle = "#e8d7a5";
      ctx.lineWidth = 10; ctx.stroke();
    }

    // ========= D√≠a/Noche =========
    const dayNightCheckbox = document.getElementById('toggleDayNight');
    dayNightCheckbox.checked = CONFIG.DAY_NIGHT;
    dayNightCheckbox.addEventListener('change', () => {
      CONFIG.DAY_NIGHT = dayNightCheckbox.checked;
    });

    function getDayNightPhase(tSec){
      // Fase 0..1 (0 = mediod√≠a claro, 0.5 = medianoche, 1 = mediod√≠a)
      const T = CONFIG.DAY_NIGHT_SECONDS;
      const phi = (tSec % T) / T; // 0..1
      // seno doblado para tener noche centrada en 0.5
      const nightness = 0.5 - 0.5 * Math.cos(2*Math.PI*phi); // 0..1
      return nightness;
    }

    function drawNightOverlay(tSec){
      if (!CONFIG.DAY_NIGHT) return;
      const nightness = getDayNightPhase(tSec); // 0..1

      // Liger√≠simo tinte al atardecer/amanecer, m√°s fuerte de noche
      const maxAlpha = 0.55; // cu√°n oscura la noche
      const alpha = nightness * maxAlpha;

      // Overlay azulado
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "#0b1b3a"; // azul noche
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      // Estrellas: aparecen solo cuando nightness > 0.2
      if (nightness > 0.2) {
        const starCount = Math.min(120, Math.floor((nightness-0.2)*200));
        // PRNG seeding estable para que no parpadeen de posici√≥n, solo en brillo
        const rnd = mulberry32(0xA5F42C91);
        for (let i=0; i<starCount; i++){
          const x = Math.floor(rnd() * canvas.width);
          const y = Math.floor(rnd() * canvas.height);
          // brillo pulsante
          const tw = (Math.sin(tSec*3 + i*0.37) + 1)/2; // 0..1
          const a  = 0.25 + tw*0.55; // 0.25..0.8
          ctx.save();
          ctx.globalAlpha = a * (0.4 + 0.6*nightness);
          ctx.fillStyle = "#fff8c4";
          // pixel-star 1x1 o cruz 3x3 seg√∫n ‚Äúsuerte‚Äù
          if (rnd() < 0.2) {
            // cruz peque√±a (simula destello)
            ctx.fillRect(x-1,y,1,1);
            ctx.fillRect(x+1,y,1,1);
            ctx.fillRect(x,y-1,1,1);
            ctx.fillRect(x,y+1,1,1);
            ctx.fillRect(x,y,1,1);
          } else {
            ctx.fillRect(x,y,1,1);
          }
          ctx.restore();
        }
      }
    }

    // ========= Dibujo principal + animaci√≥n idle =========
    function ensureCapacity(){
      const {waypoints}=computeWaypointsAndPolyline();
      const lastY=waypoints.length?waypoints[waypoints.length-1].y:0;
      gridH=Math.max(12,lastY+4);
      setupCrispCanvas();
    }

    function drawTiles() {
      for (let x=0; x<gridW; x++){
        for (let y=0; y<gridH; y++){
          const t = tileType(x,y);
          const index = (t===0)?0 : (t===1)?1 : (t===2)?2 : (t===3)?3 : 0;
          blitTile(index, x*tileSize, y*tileSize);
          if (t===0) sprinkleGrass(x,y);
        }
      }
    }

    function drawSprite(img, x, y, w, h) {
      const dx = CONFIG.CRISP_ALIGN ? Math.round(x) : x;
      const dy = CONFIG.CRISP_ALIGN ? Math.round(y) : y;
      ctx.drawImage(img, dx, dy, w, h);
    }

    function drawPOIAtCell(cellX, cellY, type, tSec=0) {
      if (!CONFIG.SHOW_POIS) return;
      const cx = cellX*tileSize + tileSize*0.78;
      const cy = cellY*tileSize + tileSize*0.22;

      const pulse = (Math.sin(tSec*3 + (cellX*7 + cellY*11)*0.2) + 1) / 2;
      const haloR = 7 + Math.round(3*pulse);
      const haloA = 0.18 + 0.22*pulse;

      ctx.save();
      ctx.globalAlpha = haloA;
      ctx.fillStyle = "#fff8c4";
      ctx.beginPath();
      ctx.arc(Math.round(cx), Math.round(cy), haloR, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(Math.PI/4);
      const c = ({
        travel:  "#ffd27a",
        mountain:"#d2ff7a",
        game:    "#7ad2ff",
        love:    "#ff99c8",
        camera:  "#f0e3b5"
      })[type] || "#f0e3b5";
      ctx.fillStyle = c;
      ctx.fillRect(-4,-4,8,8);
      ctx.restore();
    }

    function drawHouseAndAvatars(tSec=0){
      const bobJuan  = Math.round(Math.sin(tSec*2.0) * 2);
      const bobPaula = Math.round(Math.sin(tSec*2.0 + Math.PI/2) * 2);
      drawSprite(sprites.house,0,0,tileSize,tileSize);
      if(gridW>=3){
        drawSprite(sprites.juan,  1*tileSize,0+bobJuan,tileSize,tileSize);
        drawSprite(sprites.paula, 2*tileSize,0+bobPaula,tileSize,tileSize);
      }
    }

    function drawIconScaled(img, cx, cy, baseSize, scale=1) {
      const w = Math.round(baseSize * scale);
      const h = Math.round(baseSize * scale);
      const dx = Math.round(cx - w/2);
      const dy = Math.round(cy - h/2);
      ctx.drawImage(img, dx, dy, w, h);
    }

    function drawIcons(waypoints, uptoIdx = waypoints.length - 1, tSec=0){
      const baseSize = Math.round(tileSize*0.73);
      for (let k = 0; k <= uptoIdx && k < waypoints.length; k++) {
        const w = waypoints[k];
        const m = memories[w.idx];
        const icon = sprites[m.type] ?? sprites.camera;
        const bob = Math.round(Math.sin(tSec*2 + k*0.7) * 2);
        const cx = w.x*tileSize + 8 + baseSize/2;
        const cy = w.y*tileSize + 8 + baseSize/2 + bob;
        drawIconScaled(icon, cx, cy, baseSize, 1);
        drawPOIAtCell(w.x, w.y, m.type, tSec);
      }
    }

    function drawStatic(tSec=0){
      const {waypoints,polyline}=computeWaypointsAndPolyline();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawTiles();
      drawPath(polyline);
      drawNightOverlay(tSec); // overlay por encima del mundo/base
      return {waypoints, polyline};
    }

    function drawIdleFrame(tSec){
      const {waypoints} = computeWaypointsAndPolyline();
      drawHouseAndAvatars(tSec);
      drawIcons(waypoints, waypoints.length - 1, tSec);
    }

    function drawMap(tSec=0){
      drawStatic(tSec);
      drawHouseAndAvatars(tSec);
      const {waypoints} = computeWaypointsAndPolyline();
      drawIcons(waypoints, waypoints.length - 1, tSec);
    }

    // ========= Autoenfoque =========
    function focusLastWaypointIfBelowView() {
      const { waypoints } = computeWaypointsAndPolyline();
      if (waypoints.length === 0) return;
      const last = waypoints[waypoints.length - 1];
      const center = cellCenter(last.x, last.y);
      const canvasTopPage = canvas.getBoundingClientRect().top + window.scrollY;
      const waypointYInPage = canvasTopPage + center.y;
      const viewTop = window.scrollY;
      const viewBottom = viewTop + window.innerHeight;
      const margin = tileSize * 1.5;
      if (waypointYInPage > viewBottom - margin) {
        const targetY = Math.max(0, Math.round(waypointYInPage - window.innerHeight / 2));
        window.scrollTo({ top: targetY, behavior: 'smooth' });
      }
    }

    // ========= Animaci√≥n al a√±adir (con POP) =========
    function countWaypointsVisible(polyline, uptoIdx) {
      const { waypoints } = computeWaypointsAndPolyline();
      let visible = -1;
      for (let k = 0; k < waypoints.length; k++) {
        const w = waypoints[k];
        const c = cellCenter(w.x, w.y);
        for (let i = 0; i <= uptoIdx; i++) {
          const p = polyline[i];
          if (Math.hypot(p.x - c.x, p.y - c.y) < 1e-3) { visible = k; break; }
        }
      }
      return visible;
    }

    function animateLastSegment() {
      const { waypoints, polyline } = computeWaypointsAndPolyline();
      if (waypoints.length === 0) { drawMap(); return; }

      let prevEnd = 1;
      if (memories.length > 1) {
        const prevMems = memories.slice(0, memories.length - 1);
        const keep = memories;
        memories = prevMems;
        const old = computeWaypointsAndPolyline();
        prevEnd = old.polyline.length - 1;
        memories = keep;
      }
      const totalEnd = polyline.length - 1;
      const DURATION = CONFIG.ANIM_DURATION_MS;
      let start = null;

      function render(progressIdx, tSec) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTiles();
        drawPath(polyline, progressIdx);
        drawNightOverlay(tSec);

        drawHouseAndAvatars(tSec);

        const visibleWp = countWaypointsVisible(polyline, progressIdx);
        const wps = computeWaypointsAndPolyline().waypoints;
        const baseSize = Math.round(tileSize*0.73);

        for (let k=0; k <= visibleWp; k++){
          const w = wps[k];
          const m = memories[w.idx];
          const icon = sprites[m.type] ?? sprites.camera;

          const bob = Math.round(Math.sin(tSec*2 + k*0.7) * 2);
          const cx = w.x*tileSize + 8 + baseSize/2;
          const cy = w.y*tileSize + 8 + baseSize/2 + bob;

          let scale = 1;
          if (k === visibleWp) {
            const prog = (progressIdx - (prevEnd)) / Math.max(1, (totalEnd - prevEnd));
            const popPhase = clamp((prog - 0.7) / 0.3, 0, 1);
            scale = 0.9 + 0.1 * easeInOut(popPhase);
          }
          drawIconScaled(icon, cx, cy, baseSize, scale);
          drawPOIAtCell(w.x, w.y, m.type, tSec);
        }

        const a = polyline[progressIdx];
        if (sprites.juan && sprites.juan.width) {
          ctx.drawImage(sprites.juan, Math.round(a.x-16), Math.round(a.y-16), 32, 32);
        } else {
          ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(Math.round(a.x), Math.round(a.y), 5, 0, Math.PI*2); ctx.fill();
        }
      }

      function step(ts) {
        if (!start) start = ts;
        const t = Math.min(1, (ts - start) / DURATION);
        const eased = easeInOut(t);
        const idx = Math.max(prevEnd, Math.min(totalEnd, Math.floor(prevEnd + eased * (totalEnd - prevEnd))));
        render(idx, ts/1000);
        if (t < 1) requestAnimationFrame(step);
        else drawMap(ts/1000);
      }
      requestAnimationFrame(step);
    }

    // ========= UI Modales, etc. =========
    function showModal(el){ el.classList.add('show'); document.body.classList.add('no-scroll'); }
    function hideModal(el){ el.classList.remove('show'); document.body.classList.remove('no-scroll'); }
    function closeModal(){ hideModal(modal); }

    const openAddModalBtn=document.getElementById("openAddModal");
    const addModal=document.getElementById("addModal");
    const cancelAdd=document.getElementById("cancelAdd");
    const saveAdd=document.getElementById("saveAdd");
    const addTitle=document.getElementById("addTitle");
    const addText=document.getElementById("addText");
    const addType=document.getElementById("addType");
    const addMeta=document.getElementById("addMeta");

    function openAddModal(){
      addTitle.value=""; addText.value="";
      addType.value="camera";
      addMeta.textContent=`√çndice: ${memories.length} ¬∑ Fecha: ${new Date().toLocaleString()}`;
      showModal(addModal);
      setTimeout(()=>addTitle.focus(),0);
    }

    openAddModalBtn.addEventListener("click", openAddModal);
    cancelAdd.addEventListener("click",()=> hideModal(addModal));
    saveAdd.addEventListener("click",()=>{
      const title=addTitle.value.trim(), text=addText.value.trim(), type=addType.value;
      if(!title||!text) return alert("Completa todos los campos.");

      memories.push({title,text,type,createdAt:new Date().toISOString()});
      localStorage.setItem("memories",JSON.stringify(memories));

      ensureCapacity();
      focusLastWaypointIfBelowView();
      animateLastSegment();

      hideModal(addModal);
    });

    const modal=document.getElementById("modal");
    const titleEl=document.getElementById("memoryTitle");
    const idRow=document.getElementById("idRow");
    const editTitle=document.getElementById("editTitle");
    const editText=document.getElementById("editText");
    const editType=document.getElementById("editType");
    const saveBtn=document.getElementById("saveBtn");
    const deleteBtn=document.getElementById("deleteBtn");
    let currentIdx=null;

    canvas.addEventListener("click",e=>{
      const rect=canvas.getBoundingClientRect();
      const gx=Math.floor((e.clientX-rect.left)/tileSize);
      const gy=Math.floor((e.clientY-rect.top)/tileSize);

      const {waypoints}=computeWaypointsAndPolyline();
      const hit=waypoints.find(w=>w.x===gx&&w.y===gy);
      if(!hit) return;

      scrollToWaypointCenter(hit, 350, () => {
        currentIdx=hit.idx; const m=memories[currentIdx];
        const fallback=({mountain:"Senderismo üèîÔ∏è",travel:"Viaje ‚úàÔ∏è",game:"Videojuego üéÆ",love:"Rom√°ntico ‚ù§Ô∏è",camera:"Recuerdo üì∏"})[m.type]??"Recuerdo";
        titleEl.textContent=m.title||fallback;
        idRow.textContent=`√çndice: ${currentIdx} ¬∑ Fecha: ${new Date(m.createdAt).toLocaleString()}`;
        editTitle.value=m.title||""; editText.value=m.text||""; editType.value=m.type;
        showModal(modal);
      });
    });

    function scrollToWaypointCenter(wpCell, delayOpenMs = 350, cb = null) {
      const center = cellCenter(wpCell.x, wpCell.y);
      const canvasTopPage = canvas.getBoundingClientRect().top + window.scrollY;
      const waypointYInPage = canvasTopPage + center.y;

      const viewTop = window.scrollY;
      const viewBottom = viewTop + window.innerHeight;
      const margin = tileSize * 1.5;

      if (waypointYInPage > viewTop + margin && waypointYInPage < viewBottom - margin) {
        cb && cb(); return;
      }
      const targetY = Math.max(0, Math.round(waypointYInPage - window.innerHeight/2));
      window.scrollTo({ top: targetY, behavior: 'smooth' });
      setTimeout(()=>{ cb && cb(); }, delayOpenMs);
    }

    saveBtn.addEventListener("click",()=>{
      if(currentIdx==null)return;
      memories[currentIdx].title=editTitle.value.trim()||"Recuerdo";
      memories[currentIdx].text=editText.value.trim();
      memories[currentIdx].type=editType.value;
      localStorage.setItem("memories",JSON.stringify(memories));
      closeModal();drawMap();
    });

    deleteBtn.addEventListener("click",()=>{
      if(currentIdx==null)return;
      if(!confirm("¬øSeguro que quieres eliminar este recuerdo?"))return;
      memories.splice(currentIdx,1);
      localStorage.setItem("memories",JSON.stringify(memories));
      currentIdx=null;closeModal();ensureCapacity();rebuildStatic();
    });

    ;[addModal, modal].forEach(m => m.addEventListener('click', (e) => { if (e.target === m) hideModal(m); }));
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (addModal.classList.contains('show')) hideModal(addModal);
        if (modal.classList.contains('show')) hideModal(modal);
      }
    });

    // ========= Idle loop =========
    let idleRAF = null;
    function idleFrame(ts){
      if (!CONFIG.ANIM_IDLE) return;
      const tSec = ts/1000;
      drawStatic(tSec);
      drawIdleFrame(tSec);
      idleRAF = requestAnimationFrame(idleFrame);
    }
    function startIdleLoop(){
      if (!CONFIG.ANIM_IDLE) return;
      if (idleRAF) cancelAnimationFrame(idleRAF);
      idleRAF = requestAnimationFrame(idleFrame);
    }
    function rebuildStatic(){ drawMap(); }

    // Inicial
    ensureCapacity();
    rebuildStatic();
    startIdleLoop();

    window.addEventListener('resize', () => { ensureCapacity(); rebuildStatic(); });
  </script>
</body>
</html>
